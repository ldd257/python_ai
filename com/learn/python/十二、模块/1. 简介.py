"""
在前面我们脚本是用 Python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。
为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块（Module）。
模块是一个包含所有你定义的函数和变量的文件，其后缀名是 .py 。模块可以被别的程序引入，以使用该模块中的函数等
功能。这也是使用 Python 标准库的方法。
"""

"""
什么是模块
1. 容器 -> 数据的封装
2. 函数 -> 语句的封装
3. 类 -> 方法和属性的封装
4. 模块 -> 程序文件
【例子】创建一个 hello.py 文件
"""
# hello.py
def hi():
 print('Hi everyone, I love lsgogroup!')

"""
命名空间
命名空间因为对象的不同，也有所区别，可以分为如下几种：
1. 内置命名空间（Built-in Namespaces）：Python 运行起来，它们就存在了。内置函数的命名空间都属于内置命名空
间，所以，我们可以在任何程序中直接运行它们，比如 id() ,不需要做什么操作，拿过来就直接使用了。
2. 全局命名空间（Module：Global Namespaces）：每个模块创建它自己所拥有的全局命名空间，不同模块的全局命名空
间彼此独立，不同模块中相同名称的命名空间，也会因为模块的不同而不相互干扰。
3. 本地命名空间（Function & Class：Local Namespaces）：模块中有函数或者类，每个函数或者类所定义的命名空间就
是本地命名空间。如果函数返回了结果或者抛出异常，则本地命名空间也结束了。

程序在查询上述三种命名空间的时候，就按照从里到外的顺序，即：Local Namespaces --> Global Namesspaces --> Built-in Namesspaces。
"""
import hello
hello.hi() # Hi everyone, I love lsgogroup!
hi() # NameError: name 'hi' is not defined


"""
导入模块
第一种：import 模块名
第二种：from 模块名 import 函数名


 if __name__ == '__main__'
对于很多编程语言来说，程序都必须要有一个入口，而 Python 则不同，它属于脚本语言，不像编译型语言那样先将程序
编译成二进制再运行，而是动态的逐行解释运行。也就是从脚本第一行开始运行，没有统一的入口。
假设我们有一个 const.py 文件，内容如下：
"""

PI = 3.14
def main():
 print("PI:", PI)
main()
# PI: 3.14


"""
包（package）
包是一种管理 Python 模块命名空间的形式，采用"点模块名称"。
创建包分为三个步骤：
1. 创建一个文件夹，用于存放相关的模块，文件夹的名字即包的名字。
2. 在文件夹中创建一个 __init__.py 的模块文件，内容可以为空。
3. 将相关的模块放入文件夹中。
不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个"包"）。
现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，.aiff，.au），所以你需要有一组不断增加
的模块，用来在不同的格式之间转换。
并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你
还需要一组怎么也写不完的模块来处理这些操作。
这里给出了一种可能的包结构（在分层的文件系统中）:
在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。
目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，最简单的情况，放一个空的 __init__.py 就可以
了
"""